{"version":3,"sources":["../src/index.ts"],"sourcesContent":["const defaultTimeout = 0; // 0 means wait indefinitely\nconst defaultTimeoutMessage = 'The FM script call timed out';\nconst callbackName = 'fmGoferCallbackD7738642C91848E08720EAC24EDDA483';\n\n/**\n * generates a uuid without hyphens. It uses Math.random, so it's not *that* unique.\n * from https://stackoverflow.com/a/2117523\n *\n */\nfunction fmGoferUUID() {\n  const template = 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx';\n  return template.replace(/[xy]/g, (c) => {\n    var r = (Math.random() * 16) | 0,\n      v = c == 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nfunction fmGoferExists() {\n  return (\n    typeof window.fmGofer === 'object' &&\n    window.fmGofer !== null &&\n    !Array.isArray(window.fmGofer)\n  );\n}\n\nfunction initializeGofer() {\n  if (fmGoferExists()) return;\n  window.fmGofer = {\n    promises: {},\n    callbackName: callbackName,\n  };\n  window[callbackName] = runCallback;\n}\n\n/**\n * stores a callback promise and returns a promise id.\n * You can resolve or reject the promise using runCallback()\n * the promise will be rejected automatically if timeout exceeded\n *\n * @param {function} resolve\n * @param {function} reject\n * @param {number} timeout time in ms. 0 will wait indefinitely.\n * @param {string} timeoutMessage custom timeout message\n * @returns {number} the promise id\n * @private\n */\nfunction storePromise(\n  resolve: Function,\n  reject: Function,\n  timeout: number,\n  timeoutMessage: string\n) {\n  const promiseID = fmGoferUUID();\n  const promise: GoferPromise = { resolve, reject };\n  if (timeout !== 0) {\n    promise.timeoutID = setTimeout(() => {\n      if (promise.fmOnReadyIntervalID)\n        clearInterval(promise.fmOnReadyIntervalID);\n      deletePromise(promiseID);\n      reject(timeoutMessage);\n    }, timeout);\n  }\n  window.fmGofer.promises[promiseID] = promise;\n  return promiseID;\n}\n\nfunction getPromise(id: string) {\n  return window.fmGofer.promises[id];\n}\nfunction deletePromise(id: string) {\n  const promise = window.fmGofer?.promises?.[id];\n  if (promise) {\n    if (promise.timeoutID) clearTimeout(promise.timeoutID);\n    if (promise.fmOnReadyIntervalID) clearInterval(promise.fmOnReadyIntervalID);\n  }\n  // const { timeoutID, fmOnReadyIntervalID } = window.fmGofer?.promises?.[id];\n  return delete window.fmGofer.promises[id];\n}\n\n/**\n * Resolve or reject a saved callback promise.\n *\n * @param {string} promiseID promise id\n * @param {string} [result=undefined] any parameter you wish to return to the webapp. NOTE, FM passes all function params as text, so if you return JSON, be sure to JSON.parse() it.\n * @param {string} [isError=undefined] A truthy or falsey string. '0' string is treated as falsey. Pass in a truthy string to reject the promise.\n * @private\n */\nfunction runCallback(promiseID: string, result?: string, isError?: IsError) {\n  try {\n    // FM passes params as strings. JS treats '0' as truthy, but we want it to be falsey\n    if (isError === '0') isError = '';\n    const promise = getPromise(promiseID);\n    if (typeof promise === 'undefined')\n      throw new Error(`No promise found for promiseID ${promiseID}.`);\n    if (promise.timeoutID) clearTimeout(promise.timeoutID);\n    if (!!isError) promise.reject(result);\n    else promise.resolve(result);\n    deletePromise(promiseID);\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nfunction fmOnReady_PerformScriptWithOption(\n  script: string,\n  param?: any,\n  option?: ScriptOption\n) {\n  let intervalID: ReturnType<typeof setInterval>;\n  const promise = new Promise<void>((resolve, reject) => {\n    // check if window.FileMaker already exists\n    if (typeof window.FileMaker === 'object') {\n      window.FileMaker.PerformScriptWithOption(script, param, option);\n      return;\n    }\n    // else, wait for FileMaker to appear\n    const intervalMs = 5;\n    const maxWaitMs = 2000;\n    let totalWaited = 0;\n    intervalID = setInterval(() => {\n      totalWaited += intervalMs;\n      if (totalWaited > maxWaitMs) {\n        clearInterval(intervalID);\n        reject(`window.FileMaker not found within ${maxWaitMs} ms`);\n      }\n      if (typeof window.FileMaker === 'object') {\n        clearInterval(intervalID);\n        window.FileMaker.PerformScriptWithOption(script, param, option);\n        resolve();\n      }\n    }, intervalMs);\n  });\n  return {\n    promise: promise,\n    intervalID: intervalID,\n  };\n}\n\n// types to describe a JSON Object or Array as the default generic type for FMGPromise\ntype JsonValue = string | number | boolean | null | JsonObject | JsonArray;\ninterface JsonObject {\n  [key: string]: JsonValue;\n}\ninterface JsonArray extends Array<JsonValue> {}\n\nexport class FMGPromise extends Promise<string> {\n  json<T = JsonObject | JsonArray>() {\n    return this.then((text: string) => JSON.parse(text) as T);\n  }\n}\n\n/**\n * Perform a FileMaker Script with option. FM can return a result by resolving or rejecting\n * @function\n *\n * @param {string} script name of script\n * @param {any} [parameter=undefined] parameter you wish to send to fm. It will be nested in the `parameter` property of the script parameter\n * @param {ScriptOption} option script option between 0 and 5\n * @param {number} [timeout=15000] timeout in ms. 0 will wait indefinitely.\n * @param {string} [timeoutMessage='The FM script call timed out'] custom message if the call times out.\n * @returns {FMGPromise} a promise that FileMaker can resolve or reject\n */\nexport function PerformScriptWithOption(\n  script: string,\n  parameter?: any,\n  option?: ScriptOption,\n  timeout: number = defaultTimeout,\n  timeoutMessage: string = defaultTimeoutMessage\n) {\n  if (typeof script !== 'string' || !script)\n    throw new Error('script must be a string');\n  if (typeof timeout !== 'number') throw new Error('timeout must be a number');\n  if (typeof timeoutMessage !== 'string')\n    throw new Error('timeoutMessage must be a string');\n\n  return new FMGPromise(async (resolve, reject) => {\n    initializeGofer();\n    // store resolve and reject for calling outside this scope\n    const promiseID = storePromise(resolve, reject, timeout, timeoutMessage);\n    const paramObj: GoferParam = {\n      promiseID,\n      callbackName,\n      parameter,\n    };\n    const param = JSON.stringify(paramObj);\n    // try performing FM script.\n    try {\n      const { promise, intervalID } = fmOnReady_PerformScriptWithOption(\n        script,\n        param,\n        option\n      );\n      // store the interval id in the gofer promise so it can clear the interval\n      // if the custom timeout is exceeded\n      window.fmGofer.promises[promiseID].fmOnReadyIntervalID = intervalID;\n      await promise;\n    } catch (error) {\n      deletePromise(promiseID);\n      reject(error);\n    }\n  });\n}\n\n/**\n * Perform a FileMaker Script. FM can return a result by resolving or rejecting\n * @function\n *\n * @param {string} script name of script\n * @param {any} [parameter=undefined] parameter you wish to send to fm. It will be nested in the `parameter` property of the script parameter\n * @param {number} [timeout=15000] timeout in ms. 0 will wait indefinitely.\n * @param {string} [timeoutMessage='The FM script call timed out'] custom message if the call times out.\n * @returns {Promise<string>} a promise that FileMaker can resolve or reject\n */\nexport function PerformScript(\n  script: string,\n  parameter: any = undefined,\n  timeout: number = defaultTimeout,\n  timeoutMessage: string = defaultTimeoutMessage\n): FMGPromise {\n  const option = undefined;\n  return PerformScriptWithOption(\n    script,\n    parameter,\n    option,\n    timeout,\n    timeoutMessage\n  );\n}\n\nexport const Option = {\n  Default: 0,\n  Continue: 0,\n  Halt: 1,\n  Exit: 2,\n  Resume: 3,\n  Pause: 4,\n  SuspendAndResume: 5,\n} as const;\n\n// then a function can use this to define its allowed types\ntype Option = typeof Option[keyof typeof Option];\n\ntype ScriptOption = Option | '0' | '1' | '2' | '3' | '4' | '5';\n\ninterface GoferPromise {\n  resolve: Function;\n  reject: Function;\n  timeoutID?: ReturnType<typeof setTimeout>;\n  fmOnReadyIntervalID?: ReturnType<typeof setTimeout>;\n}\n\nexport interface GoferParam {\n  callbackName: typeof callbackName;\n  promiseID: string;\n  parameter: any;\n}\n\ntype IsError = '1' | '0' | '' | boolean;\nexport type GoferCallback = (\n  promiseID: string,\n  result?: string, // enforce string to emulate FM's behavior this will ensure that you remember to use JSON.parse() in any code that uses FMGofer.PerformScript*\n  isError?: IsError // even though fm can only return a string or undefined, I'm allowing boolean for convenience when using this library with fm-mock. It's much easier to pass true or false to simulate errors than '1' or '0'\n) => void;\n\ndeclare global {\n  interface Window {\n    [callbackName]: GoferCallback;\n    FileMaker: {\n      PerformScript: (scriptName: string, parameter?: string) => void;\n      PerformScriptWithOption: (\n        scriptName: string,\n        parameter?: string,\n        option?: ScriptOption\n      ) => void;\n    };\n    fmGofer: {\n      promises: {\n        [promiseID: string]: GoferPromise;\n      };\n      callbackName: string;\n    };\n  }\n}\n\nconst FMGofer = { PerformScript, PerformScriptWithOption };\nexport { FMGofer as default };\n"],"mappings":"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","names":[]}